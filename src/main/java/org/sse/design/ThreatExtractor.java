package org.sse.design;

import org.dom4j.DocumentException;
import org.sse.design.model.ThreatCategory;
import org.sse.reportparser.ReportParserFactory;
import org.sse.reportparser.design.ThreatReportParser;
import org.sse.design.model.Threat;
import org.sse.design.model.ThreatModel;

import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;

public class ThreatExtractor {

    private static ThreatExtractor instance;
    private ThreatReportParser threatReportParser;
    private ThreatModel threatModel;

    static {
        try {
            instance = new ThreatExtractor();
        } catch (Exception e) {
            throw new RuntimeException("Exception occurred in creating threat extractor ! ");
        }
    }

    private ThreatExtractor() {
        threatReportParser = ReportParserFactory.getThreatReportParser();
        threatModel = new ThreatModel();
    }

    /* getters */
    public static ThreatExtractor getInstance() {
        return instance;
    }

    public ThreatReportParser getThreatReportParser() {
        return threatReportParser;
    }

    public ThreatModel getThreatModel() {
        return threatModel;
    }

    /**
     * Read the threatModelingFile.
     * First Validate the file and then read. (Need to implement the validator)
     * Extract data from the ThreatModelingFile and get threat objects.
     * Then threatList is processed to create ThreatModel, InteractionArrayList, and ThreatArrayList
     * by using ThreatCollector object.
     *
     * @param threatModelingFile file generated by Ms TM tool 2017
     * @return
     */
    public boolean readFile(File threatModelingFile) throws DocumentException {

        getThreatReportParser().setThreatModelingFile(threatModelingFile);

        if (getThreatReportParser().validateFile()) {

            String threatModelName = getThreatReportParser().extractName();
            List<Threat> threatList = getThreatReportParser().extractThreats();

            if (threatList != null) {

                ThreatModelUtil.createThreatModel(getThreatModel(), "ID", threatModelName);
                ThreatModelUtil.createInteractionsFromThreatListAndSetToThreatModel(getThreatModel(), threatList);

                return (true);
            }
            return (false);
        } else {
            return false;
        }
    }

    /**
     * Get all threats in the current ThreatModel
     *
     * @return
     */
    public List<Threat> getAllThreats() {
        return (ThreatModelUtil.getAllThreatsFromThreatModel(getThreatModel()));
    }

    /**
     * @throws IOException
     * @throws SAXException
     * @throws ParserConfigurationException
     */
    public void classifyThreats() throws DocumentException {

        List<Threat> threatList = this.getAllThreats();
        HashMap<String, ThreatCategory> threatCategoryHashMap = ThreatCategoriesLoader.getThreatCategoryHashMap();

        for (Threat threat : threatList) {

            boolean isValidThreatCategoryName = false;

            for (String defaultThreatCategoryId : threatCategoryHashMap.keySet()) {

                ThreatCategory threatCategory = threatCategoryHashMap.get(defaultThreatCategoryId);

                String defaultThreatCategoryName = threatCategory.getName();

                if (defaultThreatCategoryName.equals(threat.getThreatCategoryName())) {

                    List<Threat> threatListForCategory = threatCategory.getThreatList();
                    threatListForCategory.add(threat);
                    threatCategory.setThreatList(threatListForCategory);

                    threatCategoryHashMap.put(defaultThreatCategoryId, threatCategory);

                    isValidThreatCategoryName = true;
                    break;
                }
            }

            if (!isValidThreatCategoryName) {
                throw new RuntimeException("Invalid Threat Category ! ");
            }
        }

        ThreatCategoriesLoader.setThreatCategoryHashMap(threatCategoryHashMap);
    }

    /**
     *
     */
    public void generateThreatReport() {

    }
}
